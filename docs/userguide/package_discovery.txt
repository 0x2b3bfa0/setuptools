.. _`package_discovery`:

===================
Package Discovery
===================

``Setuptools`` provide powerful tools to handle package discovery, including
support for namespace package. Normally, you would specify the package to be
included manually in the following manner:

.. code-block:: ini

    [options]
    packages =
        mypkg1
        mypkg2

.. code-block:: python

    setup(
        packages = ['mypkg1', 'mypkg2']
    )

This can get tiresome reallly quickly. To speed things up, we introduce two
functions provided by setuptools:

.. code-block:: ini

    [options]
    packages = find:
    #or
    packages = find_namespace:

.. code-block:: python

    from setuptools import find_packages
    #or
    from setuptools import find_namespace_packages


Using ``find:`` (``find_packages``)
===================================
Let's start with the first tool. ``find:`` (``find_packages``) takes a source
directory and two lists of package name patterns to exclude and include, and
then return a list of ``str`` representing the packages it could find. To use
it, consider the following directory

    mypkg/
        src/
            pkg1/__init__.py
            pkg2/__init__.py
            tests/__init__.py
        setup.cfg #or setup.py

To have your setup.cfg or setup.py to automatically include packages found
in ``src`` that starts with the name ``pkg`` and not ``tests``:

.. code-block:: ini

    [options]
    packages = find:
    package_dir =
        =src

    [options.packages.find]
    where = src
    include = pkg*
    exclude = tests

.. code-block:: python

    setup(
        #...
        packages = find_packages(
            where = 'src',
            include = ['pkg*',],
            exclude = ['tests',]
        ),
        package_dir = {"":"src"}
        #...
    )

Of course the keywords presented here appear arbitary and the example given
doesn't apply to every other scenarios. For best understanding, we recommend
going to :ref:`keywords_ref`.

#####WIP below#########
``find_namespace_packages()``
-----------------------------
In Python 3.3+, ``setuptools`` also provides the ``find_namespace_packages`` variant
of ``find_packages``, which has the same function signature as
``find_packages``, but works with `PEP 420`_ compliant implicit namespace
packages. Here is a minimal setup script using ``find_namespace_packages``::

    from setuptools import setup, find_namespace_packages
    setup(
        name="HelloWorld",
        version="0.1",
        packages=find_namespace_packages(),
    )


Keep in mind that according to PEP 420, you may have to either re-organize your
codebase a bit or define a few exclusions, as the definition of an implicit
namespace package is quite lenient, so for a project organized like so::


    ├── namespace
    │   └── mypackage
    │       ├── __init__.py
    │       └── mod1.py
    ├── setup.py
    └── tests
        └── test_mod1.py

A naive ``find_namespace_packages()`` would install both ``namespace.mypackage`` and a
top-level package called ``tests``! One way to avoid this problem is to use the
``include`` keyword to whitelist the packages to include, like so::

    from setuptools import setup, find_namespace_packages

    setup(
        name="namespace.mypackage",
        version="0.1",
        packages=find_namespace_packages(include=["namespace.*"])
    )

Another option is to use the "src" layout, where all package code is placed in
the ``src`` directory, like so::


    ├── setup.py
    ├── src
    │   └── namespace
    │       └── mypackage
    │           ├── __init__.py
    │           └── mod1.py
    └── tests
        └── test_mod1.py

With this layout, the package directory is specified as ``src``, as such::

    setup(name="namespace.mypackage",
          version="0.1",
          package_dir={"": "src"},
          packages=find_namespace_packages(where="src"))

.. _PEP 420: https://www.python.org/dev/peps/pep-0420/


Namespace Packages
------------------

Sometimes, a large package is more useful if distributed as a collection of
smaller eggs.  However, Python does not normally allow the contents of a
package to be retrieved from more than one location.  "Namespace packages"
are a solution for this problem.  When you declare a package to be a namespace
package, it means that the package has no meaningful contents in its
``__init__.py``, and that it is merely a container for modules and subpackages.

The ``pkg_resources`` runtime will then automatically ensure that the contents
of namespace packages that are spread over multiple eggs or directories are
combined into a single "virtual" package.

The ``namespace_packages`` argument to ``setup()`` lets you declare your
project's namespace packages, so that they will be included in your project's
metadata.  The argument should list the namespace packages that the egg
participates in.  For example, the ZopeInterface project might do this::

    setup(
        # ...
        namespace_packages=["zope"]
    )

because it contains a ``zope.interface`` package that lives in the ``zope``
namespace package.  Similarly, a project for a standalone ``zope.publisher``
would also declare the ``zope`` namespace package.  When these projects are
installed and used, Python will see them both as part of a "virtual" ``zope``
package, even though they will be installed in different locations.

Namespace packages don't have to be top-level packages.  For example, Zope 3's
``zope.app`` package is a namespace package, and in the future PEAK's
``peak.util`` package will be too.

Note, by the way, that your project's source tree must include the namespace
packages' ``__init__.py`` files (and the ``__init__.py`` of any parent
packages), in a normal Python package layout.  These ``__init__.py`` files
*must* contain the line::

    __import__("pkg_resources").declare_namespace(__name__)

This code ensures that the namespace package machinery is operating and that
the current package is registered as a namespace package.

You must NOT include any other code and data in a namespace package's
``__init__.py``.  Even though it may appear to work during development, or when
projects are installed as ``.egg`` files, it will not work when the projects
are installed using "system" packaging tools -- in such cases the
``__init__.py`` files will not be installed, let alone executed.

You must include the ``declare_namespace()``  line in the ``__init__.py`` of
*every* project that has contents for the namespace package in question, in
order to ensure that the namespace will be declared regardless of which
project's copy of ``__init__.py`` is loaded first.  If the first loaded
``__init__.py`` doesn't declare it, it will never *be* declared, because no
other copies will ever be loaded!
