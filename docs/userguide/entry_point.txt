==========================================
Entry Points and Automatic Script Creation
==========================================

When installing a package, you may realize you can invoke some commands without
explicitly calling the python interpreter. For example, instead of calling
``python -m pip install`` you can just do ``pip install``. The magic behind
this is entry point, a keyword passed to your ``setup.cfg`` or ``setup.py``
to create script wrapped around function in your libraries.


Using entry point in your package
=================================
Let's start with an example. Suppose you have written your package like this:

.. code-block:: bash

    timmins/
        timmins/__init__.py
        setup.cfg
        #other necessary files

and in your ``__init__.py`` it defines a function:

.. code-block:: python

    def helloworld():
        print("Hello world")

After installing the package, you can invoke this function in the following
manner, without applying any magic:

.. code-block:: bash

    python -m mypkg.helloworld

But entry point simplifies the call and would create a wrapper script around
your function, making it behave more natively (you type in ``helloworld`` and
the ``helloworld`` function residing inside ``__init__.py`` is executed!). To
accomplish that, add the following lines to your ``setup.cfg`` or ``setup.py``:

.. code-block:: ini

    [options]
    #...
    entry_points =
        [console_scripts]
        helloworld = mypkg:helloworld

.. code-block:: python

    setup(
        #...
        entry_points = """
            [console_scripts]
            helloworld = mypkg:helloworld
            """
    )

The syntax for entry points is specified as follows:

.. code-block::

    [<type>]
    <name> = [<package>.<subpackage>.]<module>[:<object>.<object>]

where ``name`` is the name for the script you want to create, the left hand
side of ``:`` is the module that contains your function and the right hand
side is the object you want to invoke (e.g. a function). ``type`` specifies the
type of script you want to create. ``setuptools`` currently supports either
``[console_script]`` and ``[gui_script]``.

.. note::
    the syntax is not limited to ``INI`` string as demonstrated above. You can
    also pass in the values in the form of a dictionary or list. Check out
    :ref:`keyword reference <keywords_ref>` for more details

After installation, you will be able to invoke that function by simply calling
``helloworld`` on your command line. It will even do command line argument
parsing for you!

Dynamic discovery of services and plugins
=========================================
The ability of entry points isn't limited to "advertising" your functions. In
fact, its implementation allows us to achieve more powerful features, such as
supporting libraries that "plus in" to extensible applications and frameworks

For example, suppose that a blogging tool wants to support plugins
that provide translation for various file types to the blog's output format.
The framework might define an "entry point group" called ``blogtool.parsers``,
and then allow plugins to register entry points for the file extensions they
support.

This would allow people to create distributions that contain one or more
parsers for different file types, and then the blogging tool would be able to
find the parsers at runtime by looking up an entry point for the file
extension (or mime type, or however it wants to).

Note that if the blogging tool includes parsers for certain file formats, it
can register these as entry points in its own setup script, which means it
doesn't have to special-case its built-in formats.  They can just be treated
the same as any other plugin's entry points would be.

If you're creating a project that plugs in to an existing application or
framework, you'll need to know what entry points or entry point groups are
defined by that application or framework.  Then, you can register entry points
in your setup script.  Here are a few examples of ways you might register an
``.rst`` file parser entry point in the ``blogtool.parsers`` entry point group,
for our hypothetical blogging tool::

    setup(
        # ...
        entry_points={"blogtool.parsers": ".rst = some_module:SomeClass"}
    )

    setup(
        # ...
        entry_points={"blogtool.parsers": [".rst = some_module:a_func"]}
    )

    setup(
        # ...
        entry_points="""
            [blogtool.parsers]
            .rst = some.nested.module:SomeClass.some_classmethod [reST]
        """,
        extras_require=dict(reST="Docutils>=0.3.5")
    )

The ``entry_points`` argument to ``setup()`` accepts either a string with
``.ini``-style sections, or a dictionary mapping entry point group names to
either strings or lists of strings containing entry point specifiers.  An
entry point specifier consists of a name and value, separated by an ``=``
sign.  The value consists of a dotted module name, optionally followed by a
``:`` and a dotted identifier naming an object within the module.  It can
also include a bracketed list of "extras" that are required for the entry
point to be used.  When the invoking application or framework requests loading
of an entry point, any requirements implied by the associated extras will be
passed to ``pkg_resources.require()``, so that an appropriate error message
can be displayed if the needed package(s) are missing.  (Of course, the
invoking app or framework can ignore such errors if it wants to make an entry
point optional if a requirement isn't installed.)

Dependencies management for entry points
========================================
